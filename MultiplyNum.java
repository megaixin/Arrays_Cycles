//Создайте массив целых чисел, заполните его только четными числами, а затем каждый второй элемент умножьте на предыдущий. 
class MultiplyNum {
	public static void main (String []args){
		//создаем массив целых чисел
		int [] myArr = new int [6];
		//заполняем его четными числами
		for(int i = 0; i<myArr.length;i++){
			myArr[i] =  2 * i;
		}
		//выводим массив
		writeArrayOnConsole(myArr);
		
		/*
		нужно чтобы числа массива перемножались такими какими они есть изначально, а заполняли результатом другой массив
		то есть массив который сожержит в себе изначальные значения и которые будут перемножаться:
		int [] myArr = {0,2,4,6,8,10};
		и другой масив который будет сохранять результат умножения в текущей ячейке.
		int [] myArr = {0,0,8,24,48,80};
		алгоритм:
		
		// цикл:
		работа с первым массивом:
		каждое второе число массива умножается на предыдущее до конца массива
		{0,2,4,6,8,10};
		работа с вторым массивом:
		сумма умножения двух чисел ложится в текущий элемент массива
		int [] myArr = {0,0,8,24,48,80};
		
		клонировать массив?
		нам надо умножать значения в одном массиве, а результат ложить в другой как если бы это был первый.
		значения должны ложиться в ходе того как умножаются и идут по циклу дальше числа.
		два цикла? один умножает текущее число умножается на перыдущее, сумму результата тут же кладем в ячейку второго массива.
		псевдокод:
		myArr{0,2,4,6,8,10};
		myCloneArr{0,2,4,6,8,10};
		//пилим цикл
			//каждое второе значение элемента массива умножаем на предыдущее
				//внутренний цикл
					//в каждое второе значение элемента массива кладем сумму результата вычисления внешнего цикла
		нужна дополнительная переменная?
		*/
		
		
		
		
	}
	public static void writeArrayOnConsole(int[] innerMassive){
		//System.out.println("Выводим массив: ");
		for (int i = 0; i<innerMassive.length;i++){
			System.out.print(innerMassive[i]+" ");
		}
		System.out.println();
	}
	
	
	
	
	
}